---
layout: post
title: log4j
tags: log4j
categories: basicTech
published: true
---

* TOC
{:toc}


## 1 一个简单的入门例子
在控制台利用log4j打印出*hello*

#### 1.1 配置maven
```
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```

#### 1.2 配置log4j.properties
```
log4j.appender.ai88.Console=org.apache.log4j.ConsoleAppender
log4j.appender.ai88.Console.layout=org.apache.log4j.PatternLayout
log4j.appender.ai88.Console.layout.ConversionPattern=[%5p] %d{yyyy-MM-dd HH:mm:ss,SSS} %l %m%n
log4j.rootLogger=debug,ai88.Console
```
*先不解释这些配置的含义，用代码跑一下再解释更形象。*

#### 1.3 准备代码
```java
package org.ai88;

import org.apache.log4j.Logger;

public class TestLog{
    private static Logger logger = Logger.getLogger(TestLog.class);
    
    public static void main(String[] args){
        logger.debug("hello");
    }
}
```
```
执行之后控制台输出如下：
[DEBUG] 2020-10-03 21:28:30,744 com.unitechs.TestLog.main(TestLog.java:9) hello
```

## 2 通过例子初步理解log4j.properties
#### 2.1 appender
    日志的输出形式，常见的有输出到控制台，输出到文件等等。

#### 2.2 ai88.Console
    我们给appender起的一个名字，一般是`公司名称.日志输出形式`。
    所以这里的ai88.Console就表示，公司是ai88，输出形式是Console，代表控制台的意思。
    当然，你也可以叫其他的。

#### 2.3 org.apache.log4j.ConsoleAppender
    真正实现控制台输出的类，log4j框架提供的。

#### 2.4 第一行小结
    所以，第一行`log4j.appender.ai88.Console=org.apache.log4j.ConsoleAppender`
    我们主要干了两件事：
    1. 给appender起了个名字；
    2. 我们让日志从控制台输出。

#### 2.5 layout
    就是其字面意思，样式。

#### 2.6 PatternLayout
    PatternLayout的含义为 用户自定义样式。

#### 2.7 第二行小结
    我们设置了日志输出样式为自定义样式。
    另外，log4j提供了很多样式供我们选择，例如：
    - org.apache.log4j.HTMLLayout（以HTML表格形式布局）
    - org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
    - org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）
    - org.apache.log4j.PatternLayout （用户自定义）

#### 2.8 ConversionPattern
    既然你上面选择了自定义的样式，那么就得自己去指定具体的样式了。
    这个单词就是这个含义：指定何种样式

#### 2.9 参数
    log4j的样式，我们通过这些有具体含义的参数去控制。
    - `%p` 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL
    - `%d`
      输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy
      MMM dd HH:mm:ss,SSS}
    - `%n` 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”
    - `%c` 输出所属的类目，通常就是所在类的全名
    - `%M` 输出方法的名称
    - `%m` 输出具体的消息，注意这里是小写的
    - `%r` 输出自应用启动到输出该log信息耗费的毫秒数
    - `%t` 输出产生该日志事件的线程名
    - `%l`
      输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main

#### 2.10 第三行小结
    很显然，我们通过关键字ConversionPattern设置了日志输出应该有的样式。
    这里的`%5p`，为啥有个数字5呢？因为我们的等级最多有5个字母，但是info只有4个字母，
    我们用5的意思就是，虽然info只有4个字母，但是我们也让它占5个格子。
    多出来的格子用空格占着，这样看起来很整齐。

## 3 玩一玩

#### 3.1 使用一下其他格式
    我们就试一下 `org.apache.log4j.HTMLLayout` ，既然我们选择了log4j提供的样式。
    那么我们第三行就可以去掉了，因为已经不需要我们再去提供自定义样式了。
    现在log4j.properties如下
```properties
# 设置
log4j.rootLogger = debug,ai88.Console

# 输出信息到控制台
log4j.appender.ai88.Console=org.apache.log4j.ConsoleAppender
log4j.appender.ai88.Console.layout=org.apache.log4j.HTMLLayout
```
执行代码，控制台输出结果如下：
```properties
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Log4J Log Messages</title>
<style type="text/css">
<!--
body, table {font-family: arial,sans-serif; font-size: x-small;}
th {background: #336699; color: #FFFFFF; text-align: left;}
-->
</style>
</head>
<body bgcolor="#FFFFFF" topmargin="6" leftmargin="6">
<hr size="1" noshade>
Log session start time Sat Oct 03 22:16:54 CST 2020<br>
<br>
<table cellspacing="0" cellpadding="4" border="1" bordercolor="#224466" width="100%">
<tr>
<th>Time</th>
<th>Thread</th>
<th>Level</th>
<th>Category</th>
<th>Message</th>
</tr>

<tr>
<td>0</td>
<td title="main thread">main</td>
<td title="Level"><font color="#339933">DEBUG</font></td>
<td title="com.unitechs.TestLog category">com.unitechs.TestLog</td>
<td title="Message">hello</td>
</tr>
```
    果然是html的样式。

#### 3.2 我把*%5p*换成*%4p*之后，debug会少一个字母吗
    并不会，debug还是正常打印出来的

#### 3.3 %l看起来很吊的样子，我要试一试
```
相当于 %C:%M 还加了一个代码的位置，确实超级棒
[DEBUG] 2020-10-04 15:45:12,389 com.unitechs.TestLog.main(TestLog.java:9) hello
```

## 4 日志输出到文件
    在实际生产环境中，我们不可能一直盯着linux的屏幕输出。常见的做法是去搞个日志文件，
    log4j给我们提供了一种比较常用的文件日志框架：可以按时间戳生成日志文件。
    配置如下：

```properties
# 设置
log4j.rootLogger = debug,ai88.Console,ai88.File

# 输出日志到控制台
log4j.appender.ai88.Console=org.apache.log4j.ConsoleAppender
log4j.appender.ai88.Console.layout=org.apache.log4j.PatternLayout
log4j.appender.ai88.Console.layout.ConversionPattern=[%5p] %d{yyyy-MM-dd HH:mm:ss,SSS} %l %m%n

# 输出日志到文件
log4j.appender.ai88.File=org.apache.log4j.DailyRollingFileAppender
log4j.appender.ai88.File.file=/Users/pythonbug/Desktop/ai88.log
log4j.appender.ai88.File.DatePattern=.yyyy-MM-dd
log4j.appender.ai88.File.layout=org.apache.log4j.PatternLayout
log4j.appender.ai88.File.layout.ConversionPattern=[%5p] %d{yyyy-MM-dd HH:mm:ss,SSS} %l %m%n
```

#### 4.1 输出的日志文件
    当天的文件，就是直接ai88.log。其他时间的日志文件会以指定的时间戳结尾。
    例如，这里指定的是DatePattern=.yyyy-MM-dd。则昨天的日志文件名称就是ai88.log.2020-10-02（今天是2020-10-03）
    只要是同一天的日志，默认是自动添加在最后的。所以不用担心。
    一般在生产上，我们都会用两个输出源：一个控制台，给自己调试代码的时候使用；一个文件，在生产环境上查看。

## 5 日志等级

#### 5.1 等级关系
    日志等级按照严重关系排序为debug<info<warn<error<fatal<off。一般，我们只用到前面四个。

#### 5.2 一个疑问
    我在log4j.properties中配置等级为debug，但是在代码中把debug,info,warn,error都用上。
    会输出什么？

```properties
log4j.rootLogger=debug,ai88.Console
```

```java
package com.unitechs;

import org.apache.log4j.Logger;

public class TestLog {
    public static Logger logger = Logger.getLogger(TestLog.class);

    public static void main(String[] args) {
        logger.debug("debug");
        logger.info("info");
        logger.warn("warn");
        logger.error("error");
    }
}
```

#### 5.3 做实验
###### 实验1：log4j.rootLogger=debug
```shell script
# 实验1结果如下
[DEBUG] 2020-10-04 17:11:53,747 com.unitechs.TestLog.main(TestLog.java:9) debug
[ INFO] 2020-10-04 17:11:53,749 com.unitechs.TestLog.main(TestLog.java:10) info
[ WARN] 2020-10-04 17:11:53,750 com.unitechs.TestLog.main(TestLog.java:11) warn
[ERROR] 2020-10-04 17:11:53,750 com.unitechs.TestLog.main(TestLog.java:12) error
```

###### 实验2：log4j.rootLogger=info*实验2结果如下*
```shell script
# 实验2结果如下
[ INFO] 2020-10-04 17:11:53,749 com.unitechs.TestLog.main(TestLog.java:10) info
[ WARN] 2020-10-04 17:11:53,750 com.unitechs.TestLog.main(TestLog.java:11) warn
[ERROR] 2020-10-04 17:11:53,750 com.unitechs.TestLog.main(TestLog.java:12) error
```

###### 实验3：log4j.rootLogger=warn

```shell script
# 实验3结果如下
[ WARN] 2020-10-04 17:16:10,241 com.unitechs.TestLog.main(TestLog.java:11) warn
[ERROR] 2020-10-04 17:16:10,243 com.unitechs.TestLog.main(TestLog.java:12) error
```

###### 实验4：log4j.rootLogger=error
```shell script
# 实验4结果如下
[ERROR] 2020-10-04 17:17:00,757 com.unitechs.TestLog.main(TestLog.java:12) error
```

#### 5.4 小口诀
    打印自身，带着大佬
    解释：rootLogger指定的级别肯定会打印出来，比指定级别更加严重的级别，也可以打印出来的。

## 6 一些实用小场景
假设有如下一段代码：
```java
package com.unitechs;

import org.apache.log4j.Logger;

public class TestLog {
    public static Logger logger = Logger.getLogger(TestLog.class);

    public static void main(String[] args) {
        getValue(2);
    }

    public static void getValue(int a) {
        try {
            logger.debug("程序开始执行");
            int b = 10 / a;
        } catch (Exception e) {
            logger.error(e.getMessage(), e.getCause());
        }
    }
}
```
    老板说，这段代码还是比较稳定的，但是每天打印的debug日志太多了，而且都没啥用处。现在需要
    改成只在报错的情况下才打印日志。

#### 6.1 可配置文件的好处
    我们可以不用改代码就实现上面的要求，直接把配置文件log4j.properties的log4j.rootLogger改成error级别即可。
    根据上面的口诀，只要error和比error还要严重的才能打印出来。
    下面我们来试试：

```shell script
# 未修改log4j.rootLogger
## 传入参数5
[DEBUG] 2020-10-04 18:28:24,830 com.unitechs.TestLog.getValue(TestLog.java:14) 程序开始执行
```

```shell script
# 未修改log4j.rootLogger
## 传入参数0 引发报错
[DEBUG] 2020-10-04 18:30:22,429 com.unitechs.TestLog.getValue(TestLog.java:14) 程序开始执行
[ERROR] 2020-10-04 18:30:22,431 com.unitechs.TestLog.getValue(TestLog.java:17) 程序报错了
```

```shell script
# 修改log4j.rootLogger
## 传入参数5
。。。什么也没有
```

```shell script
# 修改log4j.rootLogger
## 传入参数0
[ERROR] 2020-10-04 18:31:55,001 com.unitechs.TestLog.getValue(TestLog.java:17) 程序报错了
```
很明显，实现了我们的需求。

## 7 logger
    到现在为止，我们一直避而不谈的就是这个rootLogger了。
    我们目前只需要知道rootLogger做了两件事：
    1. 指定了日志输出级别
    2. 指定了日志输出形式
    其实我们也可以自己去配置logger，当我们没有配置自己的logger的时候，才需要rootLogger。
```properties
# 设置
log4j.rootLogger = off,ai88.Console,ai88.File
log4j.logger.com.ai88 = error,ai88.Console
```
    观察这个配置文件的第二行，log4j.logger.com.ai88。
    假设我们在com.ai88这个包下面使用了logger，那么这个包下面的logger优先使用log4j.logger.com.ai88中的配置。

#### 7.1 小实验
```properties
# 设置
log4j.rootLogger = error,ai88.Console,ai88.File
log4j.logger.com.ai88 = info,ai88.Console

# 输出日志到控制台
log4j.appender.ai88.Console=org.apache.log4j.ConsoleAppender
log4j.appender.ai88.Console.layout=org.apache.log4j.PatternLayout
log4j.appender.ai88.Console.layout.ConversionPattern=[%5p] %d{yyyy-MM-dd HH:mm:ss,SSS} %l %m%n

# 输出日志到文件
log4j.appender.ai88.File=org.apache.log4j.DailyRollingFileAppender
log4j.appender.ai88.File.file=/Users/pythonbug/Desktop/ai88.log
log4j.appender.ai88.File.DatePattern=.yyyy-MM-dd
log4j.appender.ai88.File.layout=org.apache.log4j.PatternLayout
log4j.appender.ai88.File.layout.ConversionPattern=[%5p] %d{yyyy-MM-dd HH:mm:ss,SSS} %l %m%n
```

```java
package com.ai88;

import org.apache.log4j.Logger;

public class TestLog {
    public static Logger logger = Logger.getLogger(TestLog.class);

    public static void main(String[] args) {
        logger.debug("debug");
        logger.info("info");
        logger.warn("warn");
        logger.error("error");
    }
}
```

```shell script
# 程序输出
[ INFO] 2020-10-05 16:38:12,775 com.unitechs.TestLog.main(TestLog.java:10) info
[ INFO] 2020-10-05 16:38:12,775 com.unitechs.TestLog.main(TestLog.java:10) info
[ WARN] 2020-10-05 16:38:12,777 com.unitechs.TestLog.main(TestLog.java:11) warn
[ WARN] 2020-10-05 16:38:12,777 com.unitechs.TestLog.main(TestLog.java:11) warn
[ERROR] 2020-10-05 16:38:12,777 com.unitechs.TestLog.main(TestLog.java:12) error
[ERROR] 2020-10-05 16:38:12,777 com.unitechs.TestLog.main(TestLog.java:12) error
```
    输出级别按照使用类的最精确的那个logger，所以是info，由于rootLogger的级别控制虽然失效了，但是输出控制台仍然有效。
    所以一共是6条。

#### 7.2 小总结
    当有多个logger的时候，配置文件中描述使用logger类最精确位置的那个配置项起作用。但是输出内容的时候，有多少logger就会有多少遍输出。
    假设：
    com.ai88.util.Test1中使用了logger。
    log4j.properties中配置了 (1) log4j.rootLogger,(2) log4j.logger.com.ai88,(3) log4j.logger.com.ai88.util。
    那么只有log4j.logger.com.ai88.util生效。
    输出的时候，由于有三个logger。因此，会当作有三个输出源，按照log4j.logger.com.ai88.util指定的级别一起输出。